<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java后端开发成神之路</title>
    <url>/2020/07/07/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="Java后端开发学习路径"><a href="#Java后端开发学习路径" class="headerlink" title="Java后端开发学习路径"></a>Java后端开发学习路径</h3><h4 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h4><p>​    Java语言<br>​        语言基础<br>​            基础语法<br>​            面向对象<br>​            接口<br>​            容器<br>​            异常<br>​            泛型<br>​            反射<br>​            注释<br>​            I/O<br>​            图形化（swing）</p>
<a id="more"></a>

<p>​        JVM虚拟机s<br>​            类加载机制<br>​            字节码执行机制<br>​            JVM内存模型<br>​            GC垃圾回收<br>​            JVM性能监控与故障定位<br>​            JVM调优<br>​        多线程/并发<br>​            并发编程的基础<br>​            线程池<br>​            并发容器<br>​            原子类<br>​            JUC并发工具类<br>​    数据结构和算法<br>​        数据结构<br>​            字符串<br>​            数组<br>​            链表<br>​            堆、栈、队列<br>​            二叉树<br>​            哈希<br>​            图<br>​        算法<br>​            排序<br>​            查找<br>​            贪心<br>​            分治<br>​            动态规划<br>​            回溯<br>​    计算机网络<br>​        APR协议<br>​        IP协议、ICMP协议<br>​        DNS/HTTP/HTTPS协议<br>​        Session/Cookie<br>​    SQL/数据库<br>​        SQL语句书写<br>​        SQL语句优化<br>​        事务、隔离级别<br>​        索引<br>​        锁<br>​    操作系统<br>​        进程、线程<br>​        并发、锁<br>​        内存管理和调度<br>​        I/O原理<br>​    设计模式<br>​        举例<br>​        工厂<br>​        代理<br>​        策略<br>​        模板方法<br>​        观察者<br>​        适配器<br>​        责任链<br>​        建造者</p>
<h4 id="研发工具"><a href="#研发工具" class="headerlink" title="研发工具"></a>研发工具</h4><p>​    集成开发工具<br>​        Eclipse<br>​        Interllj IDEA<br>​        VScode<br>​    Linux<br>​        常用命令<br>​        Shell脚本<br>​    项目管理/构建工具<br>​        Maven<br>​        Gradle<br>​    代码管理工具<br>​        SVN<br>​        Git</p>
<h4 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a>应用框架</h4><p>​    后端<br>​        Spring家族框架<br>​            Spring<br>​                IoC<br>​                Aop<br>​            SpringMVC<br>​            Spring Boot<br>​                自动配置、开箱即用<br>​                 整合Web<br>​                整合数据库（事务问题）<br>​                整合权限<br>​                    Shiro<br>​                    Spring Secunity<br>​                整合各种中间件<br>​                    Redis、MQ、RPC框架、NIO框架<br>​        服务器软件<br>​            Web服务器<br>​                Nginx<br>​            应用服务器<br>​                Tomcat<br>​                Jetty<br>​                Undertow<br>​        中间件<br>​            缓存<br>​                Redis<br>​                    5大基础数据类型<br>​                    事务<br>​                    管道<br>​                    持久化<br>​                    集群<br>​            消息队列<br>​                RocketMQ<br>​                RabbitMQ<br>​                Kafka<br>​            RPC框架<br>​                Dobbo<br>​                gRPC<br>​                Thrift<br>​                Spring Cloud<br>​                Netty<br>​        数据库框架<br>​            ORM层框架<br>​                Mybatis<br>​                Hbemate<br>​                JPA<br>​            连接池<br>​                Druid<br>​                HkariCP<br>​                C3P0<br>​            分库分表<br>​                MyCat<br>​                Sharding-JDBC<br>​                Sharding-Sphere<br>​        搜索引擎<br>​            ElasticSearch<br>​            Solr<br>​        分布式/微服务<br>​            服务发现/注册<br>​                Eureka<br>​                Consul<br>​                Zookeeper<br>​                Nacos<br>​            网关<br>​                Zuul<br>​                Gateway<br>​            服务调用（负载均衡）<br>​                Ribbon<br>​                Feign<br>​            熔断/降级<br>​                Hystrix<br>​            配置中心<br>​                Config<br>​                Apallo<br>​                Nacos（阿里）<br>​            认证和鉴权<br>​                Spring Security<br>​                OAuth2<br>​                SSO单点登录<br>​            分布式事务<br>​                JTA接口<br>​                    Atomikos组件<br>​                2PC、3PC<br>​                XA模式<br>​                TCC模式<br>​                    tcc-transaction<br>​                    ByteTCC<br>​                    EassyTransaction<br>​                    Seata<br>​                SAGA模式<br>​                    ServiceComb<br>​                    Seata<br>​                LCN模式<br>​                    tx-lcn<br>​            任务调度<br>​                Quartz<br>​                Elastic-Job<br>​            链路追踪和监控<br>​                Zipkin<br>​                Sleuth<br>​                Skywalking<br>​            日志分析与监控<br>​                ELK<br>​                    ElasticSearch<br>​                    Logstash<br>​                    Klbana<br>​        虚拟化/容器化<br>​            容器技术<br>​                Docker<br>​            容器编排技术<br>​                Kubernetes<br>​                Swam<br>​    前端<br>​        基础套餐<br>​            三大件<br>​                HTML<br>​                JavaScript<br>​                CSS<br>​            基础库<br>​                JQuery<br>​                Ajax<br>​        模板框架<br>​            JSP/JSTL<br>​            Thymeleaf<br>​            FreeMarker<br>​        组件化<br>​            Vue<br>​            Node<br>​            React<br>​            Angular</p>
<p>研发工具<br>    集成开发工具<br>        Eclipse<br>        Interllj IDEA<br>        VScode<br>    Linux<br>        常用命令<br>        Shell脚本<br>    项目管理/构建工具<br>        Maven<br>        Gradle<br>    代码管理工具<br>        SVN<br>        Git</p>
<p><img src="/2020/07/07/Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/%E4%BA%8C%E4%BA%BA%E5%9B%BE.png" alt></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端开发</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown编写格式简述</title>
    <url>/2020/04/27/MarkDown%E7%BC%96%E5%86%99%E6%A0%BC%E5%BC%8F%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="MarkDown编写方式：为了减少使用鼠标，专注敲键盘。"><a href="#MarkDown编写方式：为了减少使用鼠标，专注敲键盘。" class="headerlink" title="MarkDown编写方式：为了减少使用鼠标，专注敲键盘。"></a>MarkDown编写方式：为了减少使用鼠标，专注敲键盘。</h3><p><strong>推荐软件：Typora。</strong></p>
<p><strong>以下所有顶前的关键词后空格下才能触发MarkDown格式，关键词中有结尾的的不需要</strong></p>
<hr>
<h3 id="MarkDown语法简要规则"><a href="#MarkDown语法简要规则" class="headerlink" title="MarkDown语法简要规则"></a>MarkDown语法简要规则</h3><a id="more"></a>

<h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h4><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="#一级标题"></a>#一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="##二级标题"></a>##二级标题</h2><p>#越多标题越小。</p>
<h3 id="2-列表"><a href="#2-列表" class="headerlink" title="2.列表"></a>2.列表</h3><p><strong>无序关键字*，-</strong></p>
<ul>
<li>*1</li>
<li>*2<ul>
<li>1</li>
<li>2</li>
</ul>
</li>
</ul>
<p><strong>有序关键词1. 2. 3.</strong></p>
<ol>
<li>1.</li>
<li>2.</li>
</ol>
<h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h3><p>*<em>关键词 &gt; *</em></p>
<blockquote>
<p>变成这种效果。</p>
</blockquote>
<blockquote>
<blockquote>
<p>多重&gt;多重效果</p>
</blockquote>
</blockquote>
<h3 id="4-图片与链接"><a href="#4-图片与链接" class="headerlink" title="4.图片与链接"></a>4.图片与链接</h3><p><strong>图片关键词 ！【】（）</strong></p>
<p><strong>链接关键词 【】（）</strong></p>
<p>小写输入格式。</p>
<h3 id="5-粗体、划线与斜体"><a href="#5-粗体、划线与斜体" class="headerlink" title="5.粗体、划线与斜体"></a>5.粗体、划线与斜体</h3><p>*<em>粗体关键词 *</em> **</p>
<p><strong>斜体关键词 *</strong> </p>
<p><strong>划线关键词</strong> ~~</p>
<p>例如：<strong>粗体</strong>，<em>斜体</em>，<del>划线</del>。</p>
<h3 id="6-代码框"><a href="#6-代码框" class="headerlink" title="6.代码框"></a>6.代码框</h3><p>*<em>关键词 `` *</em></p>
<p><code>int main()</code></p>
<p><code>{</code></p>
<p><code>cout&lt;&lt;&quot;Hellow world!&quot;&lt;&lt;endl;</code></p>
<p><code>return 0;</code></p>
<p><code>}</code></p>
<h3 id="7-分割线"><a href="#7-分割线" class="headerlink" title="7.分割线"></a>7.分割线</h3><p><strong>关键词 ** *</strong> ，—</p>
<hr>
]]></content>
      <tags>
        <tag>MarkDown</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议</title>
    <url>/2020/06/04/TCP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="传输层：TCP协议"><a href="#传输层：TCP协议" class="headerlink" title="传输层：TCP协议"></a>传输层：TCP协议</h2><p>TCP是为了在不可靠的互联网上提供一个可靠的端到端字节流的传输协议</p>
<p>互联网络与单个网络不同，互联网络的不同部分可能有不同的拓扑结构、带宽、延迟、数据包大小等等，TCP目的是能够动态地适应这些互联网络的特性，面对各种故障时的健壮性。</p>
<p>不同主机的应用层之间经常需要可靠的、管道样的连接，IP层不提供这样的流机制，而是提供不可靠的包交换。</p>
<a id="more"></a>

<p>应用层向TCP层发送用于网间传输、8位字节表示的数据流，TCP将数据流分为适当长度的报文段（受到数据链路层的最大传输单元(MTU)限制）。之后TCP把结果包发给IP层，通过网络将包传送接收端实体的TCP层。传输过程中TCP为了保证不发生丢包，就给每个包一个序号标记，同时序号也保证了传送到接收端实体的包能按序接受。这时接收端实体对已成功接收的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延(RTT)内未接受到确认，那么对应的数据包就被假设为一丢，并进行重传。TCP用一个校验和函数来验证数据是否有误；在发送和接受时都要计算校验和。</p>
<ul>
<li>在数据正确性和合法性上，TCP用一个校验和函数来检验数据是否有误，发送端和接收端都要计算校验和；同时可以使用md5认证对数据进行加密。</li>
<li>保证可靠性上，采用超时重传和捎带确认机制。</li>
<li>流量控制上，采用滑动窗口协议，规定对于窗口内未经确认的分组需要重传。</li>
<li>拥塞控制上，采用TCP拥塞控制算法（AIMD算法），该算法包括：<ol>
<li>慢启动：每当建立一个TCP连接或者发生超时重传后，该连接进入慢启动。进入慢启动，TCP实体将拥塞窗口大小设置为一个报文段，cwnd = 1；每收到一次报文段确定（ACK），cwnd+1，堵塞窗口按指数增加。当cwnd超过慢启动阐值（ssthresh）或者报文丢失重传，慢启动结束。前者进入拥塞避免阶段，后者重新进入慢启动。</li>
<li>拥塞避免：在此阶段，每一次发送的cwnd个报文段被完全确认后，才将cwnd+1。此阶段cwnd线性增加。</li>
<li>快速重传：是超时重传的改进。当源端收到对同一个报文的三次重复确认时，确定一个报文段已经丢失，因此立刻重传丢失的报文段，不必等到重传定时器（RTO）超时，减少等待时间。</li>
<li>快速恢复：是恢复机制的改进。在快速重传之后，不经过慢启动过程而直接进入拥塞避免阶段。每当快速重传后，置ssthresh=cwnd/2、ewnd=ssthresh+3.此后，每收到一个重复确认，将cwnd+1，直至收到对丢失报文段和其后若干报文段的累积确认后，置cwnd = ssthesrh，进入拥塞避免阶段</li>
</ol>
</li>
</ul>
<p>各位好，这次我将以一个学生的角度，对于计算机网络来说，如何去能够清晰理解概念并且学完后，能在自己的脑里有个大致的知识脉络，确保学完后对于知识点里面的专有名词我能够知道它是什么意思。用思维导图来建立自己的知识体系是一个很好的办法。</p>
<p>首先，我每次看完每周的学习任务视频后，脑子里大多会很模糊。因为一个章节的知识点太多了，而且作为一个初学者，我是很难分辨视频中哪些知识点是重点是难点，可能在看视频的过程中一不留神就错过了。然后迷迷糊糊看完视频，发现自己做题的时候 还有很多要点没听到位，这时又要回去重新拉进度条，这就很麻烦了。</p>
<p>因为当时手头没有教材书，而又要对一个学习章节有个大致的脉络，对于我来说最好的方式就是求助于百科了。当然单纯看文字确实是一个枯燥的过程，不过我们只需通过百科来了解到一个学习章节的大概过程。比如TCP协议，我们能通过百科知道它的定义，它是位于传输层的协议，与之对应的还有UDP协议，而它的特点有哪些，首部字段以及可靠机制是什么。TCP的连接控制中又有：三次握手，四次挥手、同时打开、同时关闭、半关闭等等一系列的概念。</p>
<p>等我们对这些术语有了大致了解后，再通过观看学习视频的效率高很多了。同时在看的过程中记录下没搞懂的点还有一些比较重要的知识点，这对后面构建思维导图是很有帮助的。</p>
<p>构建思维导图，对于我来说最重要的一点就是，能够防忘。怎样去构建思维导图以及如何去构建属于自己的思维导图这就很重要了。因为这个东西是给自己看的，当自己学习完后，对于哪些知识点理解深浅只有自己清楚。所以哪些该详细哪些能简洁对于每个人来说都不一样。只要成功构建完思维导图后，过了2，3天回过头打开，自己还能对每个知识点快速反应过来，那么这个思维导图的目的就达到了。</p>
<p>所以这次我就拿TCP协议中的三次握手以及四次挥手来做一个导向，以下发言仅是我自己的理解以及百科与教科书知识点的整理。如有不对或有争议处欢迎指正及讨论。</p>
<p>开始我大致说明下TCP协议在网络数据传输中是怎么样运行的。</p>
<p>应用层的报文通过网间传输，以8位字节的数据流传送到传输层，TCP将数据流分割为多个数据，这些数据加上TCP首部，就构成了TCP的数据传送单位，称为报文段，同时这些报文段的长度会受到MTU（数据链路层最大传输单元）的限制。在发送时，TCP的报文段作为IP数据报的数据，加上首部后成为IP数据报。通过网络传输发给接收端，接收时接收端会将IP数据报其头部去掉交给传输层，得到TCP报文段。再去掉其首部，通过序号和确认号，正确的交付给应用层，得到其所需的报文。</p>
<p>TCP连接包括三个状态：连接创建、数据传输、连接终止。在这过程中我们要对TCP首部的信息能够了解清楚，这里教材书第201页有很详细的讲解。对于我来说标志位的英文缩写就要去着重记住其含义。特别是ACK,SYN,FIN在后面的三次握手以及四次挥手中经常会提到。MSS就是限制TCP数据部分的最大长度。</p>
<p>下面开始连接建立中的三次握手。</p>
<p>客户端的TCP向服务器的TCP发出连接请求报文段，其首部的同步比特标志位SYN置1，同时选择一个初始序号seq = A；</p>
<p>服务器的TCP收到连接请求报文段后，则发回确认，标志位ACK置1，确认号为A+1。因为连接是双向的，所以服务器也会发出和客户端的连接请求，在报文段中同时将SYN置1，为自己选择一个初始序号seq = B；</p>
<p>客户端的TCP收到此报文段后，还要向服务器给出确认，此时包的序号为A+1.ACK置1，确认号为B+1.</p>
<p>按照2次握手的协定，服务器认为连接已经建立了，可以发送数据报文段了。那为什么还需要第三次握手呢？</p>
<p>假如客户端在服务器的应答报文段在被丢失了情况下也就是第二次握手没成功，客户端不知道服务器是否已准备好，不知道服务器建议什么样的序号，也不知道服务器是否同意了自己的初始序列号，客户端这时就要怀疑人生了，它都不知道服务器有没有收到自己的连接请求报文段。在这种情况下客户端会认为连接还未建立起来，将丢弃服务器发来的任何报文段，只等待接受连接确认应答报文。</p>
<p>而服务器这边，我是做出回应了的，你自己没收到我怎么知道？就一股脑的发送，超时后又重发，这样就形成了死锁。所以第三次握手是很有必要的。</p>
<p>三次握手也会出现洪水攻击，如果再第一次握手后，客户端死机了，服务器收不到后续的报文，服务器会将收到的数据报收入缓存，大概30s-2min，如果多个客户端有这种操作，就能造成洪水攻击使服务器处理负担加重，这也是三次握手的弊端。</p>
]]></content>
      <tags>
        <tag>TCP</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题：交错字符串</title>
    <url>/2020/07/20/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%9A%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="力扣刷题：交错字符串"><a href="#力扣刷题：交错字符串" class="headerlink" title="力扣刷题：交错字符串"></a>力扣刷题：交错字符串</h3><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>给定三个字符串S1,S2,S3.验证S3是否由S1和S2<strong>交错组成</strong>。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;aabcc&quot;, s2 &#x3D; &quot;dbbca&quot;, s3 &#x3D; &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p>记|s1| = n,|s2| = m;</p>
<p><strong>思路后与算法：</strong></p>
<p><strong>双指针错在哪？</strong>：我们能用指针p1指向s1的元素，用p2指向s2的元素；p3指向s3的元素。然后通过对p1和p2，对p3一一对应，成功的下标后移；理论上可行，但实例1就成为了反例。</p>
<p>s1 = aabcc，s2 = dbbca；s3 = aadbbcbcac。</p>
<ul>
<li><p><code>p3 -&gt; a ，p1 -&gt; a，p2 -&gt; d；p1后移，s1更新 abcc；s2更新dbbca；s3更新adbbcbcac。</code></p>
</li>
<li><p><code>p3 -&gt; a ，p1 -&gt; a，p2 -&gt; d；p1后移，s1更新 bcc；s2更新dbbca；s3更新dbbcbcac。</code></p>
</li>
<li><p><code>p3 -&gt; d ，p1 -&gt; b，p2 -&gt; d；p2后移，s1更新 bcc；s2更新bbca；s3更新bbcbcac。</code></p>
</li>
<li><p><code>p3 -&gt; b ，p1 -&gt; b，p2 -&gt; b；p1后移，s1更新 cc；s2更新bbca；s3更新bcbcac。**当p1，p2指向元素相同出现分歧，我们默认取p1**</code></p>
</li>
<li><p><code>p3 -&gt; b ，p1 -&gt; c，p2 -&gt; b；p2后移，s1更新 cc；s2更新bca；s3更新cbcac。</code></p>
</li>
<li><p><code>p3 -&gt; c ，p1 -&gt; c，p2 -&gt; b；p1后移，s1更新 c；s2更新bca；s3更新bcac。</code></p>
</li>
<li><p><code>p3 -&gt; b ，p1 -&gt; c，p2 -&gt; b；p2后移，s1更新 c；s2更新ca；s3更新cac。</code></p>
</li>
<li><p><code>p3 -&gt; c ，p1 -&gt; c，p2 -&gt; c；p1后移，s1更新 0；s2更新ca；s3更新ac。</code></p>
</li>
<li><p><code>p3 -&gt; a ，p1 -&gt; 0，p2 -&gt; c；此时p3没有与之匹配的值，**双指针判断为错**，实则是正确的。</code></p>
</li>
</ul>
<p><em>双指针主要是在p1，与p2同时指向一个元素时，p3的判断会优先代码考前的指针，而导致后续顺序出错，没有与之匹配的元素</em></p>
<p><strong>动态规划思想：</strong></p>
<p>首先，如果|s1|+|s2| != |s3|。那么必不可能能全部交差。所以在|s1|+|s2| == |s3|的情况下讨论。</p>
<p>f(i,j)表示s1的前 i 个元素和s2的前 j 个元素，能否交差成s3的前 i+j 个元素。因为是顺序交差，那么s1的最后一个元素 i ，或者s2的最后一个元素 j 必在s3的 i+j 上。</p>
<p>则如果s1的 i 与s3的 i+j 相等，那么s1的前 i 个元素，与s2的前 j 个元素能否交差成s3的前 i+j 个元素，</p>
<p>取决于s1的 i-1 个元素，与s2的前 j 个元素能否交差成s3的 i+j-1个元素的<strong>前置</strong>。</p>
<p>即f(i,j)取决于f(i-1,j),<strong>此时前者要为真，后者必先为真。</strong>同时还有j-1的情况。于是有以下<strong>状态转移方程：</strong>        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">f(i,j) = &#123;f(i-<span class="number">1</span>,j) and s1[i-<span class="number">1</span>]==s3[i+j-<span class="number">1</span>] <span class="function">or <span class="title">f</span><span class="params">(i,j<span class="number">-1</span>)</span> and s2[j-1]</span>==s3[i+j-<span class="number">1</span>] &#125;</span><br></pre></td></tr></table></figure>

<p><strong>图形解释:</strong></p>
<p><img src="/2020/07/20/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%9A%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2/%E4%BA%A4%E5%B7%AE%E9%97%AE%E9%A2%98%E5%8A%9B%E6%89%A3.png" alt></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n + m != t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j] || (f[i - <span class="number">1</span>][j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j] || (f[i][j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度皆为：O（mn）。</p>
<p><strong>因为数组f的第i行只与i-1行有关，能用滚动数组来优化空间。</strong></p>
<p>滚动数组题：</p>
<p><strong>滚动数组优化：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s1.length(), m = s2.length(), t = s3.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n + m != t) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = i + j - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[j] = f[j] &amp;&amp; s1.charAt(i - <span class="number">1</span>) == s3.charAt(p);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    f[j] = f[j] || (f[j - <span class="number">1</span>] &amp;&amp; s2.charAt(j - <span class="number">1</span>) == s3.charAt(p));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>空间复杂度为s2长度O（m）。</p>
]]></content>
      <tags>
        <tag>力扣刷题，动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题：二叉树的最大深度</title>
    <url>/2020/07/28/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="力扣刷题：二叉树的最大深度"><a href="#力扣刷题：二叉树的最大深度" class="headerlink" title="力扣刷题：二叉树的最大深度"></a>力扣刷题：二叉树的最大深度</h3><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>如题，基础题，主要是巩固基础知识。已知一二叉树<code>[3,9,20,null,null,15,7]</code>，求此二叉树最大深度。</p>
<a id="more"></a>

<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p><strong>递归求解：</strong></p>
<p>不断的递归左右子树，直到根结点为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *此段为力扣API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : Math.max(maxDepth(root.left),maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>广度优先遍历：</strong></p>
<p>将根结点放入队列中，然后对根节点的左右子树判断是否为空，不为空的再加入队列。</p>
<p>每次将同一层的子树同时进行判空操作，直到队列长度全部进行完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java队列API知识巩固："><a href="#Java队列API知识巩固：" class="headerlink" title="Java队列API知识巩固："></a>Java队列API知识巩固：</h4><p><em>java.util.Queue<E></E></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(元素)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(元素)</span></span>;</span><br><span class="line">&lt;如果队列未满，将此元素添加到队尾并返回<span class="keyword">true</span>。如果已满，第一个方法抛出IllegalStateException，第二个返回<span class="keyword">false</span>&gt;</span><br><span class="line">E.remove();</span><br><span class="line">E.poll();</span><br><span class="line">&lt;队列不空，删除并返回队头元素。如果空，第一个抛出NoSuchElementException，第二个返回<span class="keyword">null</span>&gt;</span><br><span class="line">E.element();</span><br><span class="line">E.peek();</span><br><span class="line">&lt;队列不空，返回队头元素不删除。队空，一个方法抛出NoSuchElementException，第二个返回<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p><strong>offer，add 区别：</strong></p>
<p>一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。</p>
<p>这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。</p>
<p><strong>poll，remove 区别：</strong></p>
<p>remove() 和 poll() 方法都是从队列中删除第一个元素。remove() 的行为与 Collection 接口的版本相似， 但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。</p>
<p><strong>peek，element区别：</strong></p>
<p>element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。</p>
]]></content>
      <tags>
        <tag>力扣刷题</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>广度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题：两个数组交集</title>
    <url>/2020/07/15/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%9A%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h3 id="力扣刷题：两个数组交集"><a href="#力扣刷题：两个数组交集" class="headerlink" title="力扣刷题：两个数组交集"></a>力扣刷题：两个数组交集</h3><p><strong>题意：</strong></p>
<p>给定两个数组，编写个函数求它们的交集。</p>
<p>示例 1：</p>
<p><code>输入：nums1 = [1,2,2,1], nums2 = [2,2]</code><br><code>输出：[2,2]</code><br>示例 2:</p>
<p><code>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</code><br><code>输出：[4,9]</code></p>
<p>进阶：</p>
<ul>
<li><p>如果给定数组已有序，如何优化算法？</p>
</li>
<li><p>如果nums1的大小比nums2小很多，那种方法优？</p>
</li>
<li><p><strong>如果nums2的元素存在磁盘上，磁盘内存有限，不能一次加载所有元素到内存，如何解</strong>？</p>
</li>
</ul>
<a id="more"></a>

<h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p><strong>方法一：哈希表</strong></p>
<p>利用哈希表，将数组长度小的那个全部存入哈希表中，对于重复的数更新哈希中的键值对的值。然后通过new一个新的数组box记录，利用Map.getOrDefault方法，将数组2中的值与已存入map中的数组进行对比，相同就存入box并且更新键值对中的值减1。最后输出数组box。</p>
<p><strong>例码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length &gt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> intersect(nums2,nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">int</span> cout = map.getOrDefault(i,<span class="number">0</span>) + <span class="number">1</span>;  <span class="comment">//将数组nums1输入map，并且记录值的重复值。</span></span><br><span class="line">            map.put(i,cout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] box = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nums : nums2) &#123;</span><br><span class="line">            <span class="keyword">int</span> cout = map.getOrDefault(nums,<span class="number">0</span>);  <span class="comment">//将数组nums2中存在与nums1中的键值记录在cout</span></span><br><span class="line">            <span class="keyword">if</span>(cout &gt; <span class="number">0</span>) &#123;  <span class="comment">//存在时记录，更新键值对</span></span><br><span class="line">                box[sum++] = nums;</span><br><span class="line">                cout--;</span><br><span class="line">                <span class="keyword">if</span>(cout &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    map.put(nums,cout);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;  <span class="comment">//不存在移除nums2中的该数</span></span><br><span class="line">                    map.remove(nums);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(box,<span class="number">0</span>,sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：二指针定位</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">    <span class="keyword">int</span>[] box = <span class="keyword">new</span> <span class="keyword">int</span>[Math.min(length1,length2)];</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">    Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> numi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numi1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numi2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (numi1 &lt; length1 &amp;&amp; numi2 &lt; length2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[numi1] &gt; nums2[numi2]) &#123;</span><br><span class="line">            numi2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums2[numi2] &gt; nums1[numi1]) &#123;</span><br><span class="line">            numi1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            box[numi] = nums1[numi1];</span><br><span class="line">            numi1++;</span><br><span class="line">            numi2++;</span><br><span class="line">            numi++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOfRange(box,<span class="number">0</span>,numi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进阶三解法：</strong></p>
<p>对应进阶问题三，如果内存十分小，不足以将数组全部载入内存，那么必然也不能使用哈希这类费空间的算法，只 能选用空间复杂度最小的算法，即解法一。</p>
<p> 但是解法一中需要改造，一般说排序算法都是针对于内部排序，一旦涉及到跟磁盘打交道（外部排序），则需要特 殊的考虑。</p>
<p><code>归并排序</code>是天然适合外部排序的算法，可以将分割后的子数组写到单个文件中，归并时将小文件合并为 更大的文件。当两个数组均排序完成生成两个大文件后，即可使用双指针遍历两个文件，如此可以使空间复杂度最 低。 关于外部排序与JOIN，强烈推荐大家看一下 </p>
]]></content>
      <tags>
        <tag>力扣</tag>
        <tag>刷题</tag>
        <tag>Hash</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题：地下城游戏</title>
    <url>/2020/07/13/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%9A%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h3 id="力扣：地下城游戏"><a href="#力扣：地下城游戏" class="headerlink" title="力扣：地下城游戏"></a>力扣：地下城游戏</h3><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>已知一矩形地下城n*m，骑士从左上到右下去拯救公主。每个格子对应一个迷室，骑士通过时会扣除生命值或者增加生命值，求到拯救公主，骑士的最小初始生命值应为多少？</p>
<p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。</p>
<p>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p>
<p>-2 (K)    -3    3<br>-5    -10    1<br>10    30    -5 (P)</p>
<p>说明:</p>
<p>骑士的健康点数没有上限。</p>
<p>任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。</p>
<a id="more"></a>

<h4 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h4><p>按照左上往右下走的顺序动态规划，对于每一条路径，我们需要记录2个值：<strong>出发点到该点的路径和</strong>，<strong>出发点到该点最小初始值</strong>。</p>
<p><strong>举例（从起始点到1的坐标点2条明显路径对比）</strong>：</p>
<p><img src="/2020/07/13/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%9A%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F%E9%A2%98.jpg" alt></p>
<p>由图可知，第一条绿色路径的<strong>路径和</strong>为1；<strong>初始值</strong>为3。</p>
<p>第二条蓝色路径的<strong>路径和</strong>为-1；<strong>初始值</strong>为2。</p>
<p>此时我们应保证<em>路径和足够大</em>，<em>初始值足够小</em>。而这时到（1，2）目标点后走到公主点时。我们不能选择初始值更小的蓝色线路，因为公主点为-2，蓝色路径和为-1，这导致线路初始值应为4。而相比之下绿色线路初始值3</p>
<p>所以对于从左上到右下，每一次的dp，路径和与初始值都对其产生重要影响，这样的动态规划不具备<strong>无后效性</strong>。</p>
<p>于是我们能考虑从右下到左上的路径规划。令dp[i][j]表示坐标（i，j）到终点所需要的<strong>最小初始值</strong>。也就是说，当我们走到（i，j）时，如果我们的<strong>路径和</strong> &gt;= <strong>初始值：dp[i][j]</strong>就能到达终点。</p>
<p>这样我们无需关心路径和大小，只需关注初始值。对于dp[i][j],只需关心  dp[i][j+1]  和  dp[i+1][j]  的最小值<strong>minn</strong>，记录当前格子dunger（i,j），那么坐标（i，j）只需达到<strong>minn - dunger(i,j)</strong>即可，同时初始值最小得大于等于1.</p>
<p><strong>状态转移方程如下：</strong></p>
<p><strong>dp[i][j]   =  Max(    Min(dp[i][j+1] , dp[i+1][j])  - duger(i,j)     ,        1    )</strong></p>
<p>最终答案为dp[0][0]。</p>
<p><strong>边界条件：</strong></p>
<p>当 i = n-1 或 j = m-1时，dp[i][j+1]或dp[i][j+1]存在无效值，因此将其无效值赋予最大值。</p>
<p>特殊情况：当dp[n-1][m-1] = dp[n-1][m] + dp[n][m+1]; 所以令其二值为1.</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">int</span> n = dungeon.length;  </span><br><span class="line">           <span class="keyword">int</span> m = dungeon[<span class="number">0</span>].length;</span><br><span class="line">           <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    		<span class="comment">//将数组值全设为Max</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">               Arrays.fill(dp[i],Integer.MAX_VALUE);</span><br><span class="line">           &#125;</span><br><span class="line">           dp[n][m-<span class="number">1</span>] = dp[n-<span class="number">1</span>][m] = <span class="number">1</span>;  <span class="comment">//dp[n-1][m-1]时，将二值设为1.</span></span><br><span class="line"></span><br><span class="line">    		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		*从倒序开始，使之初始值其决定因素。</span></span><br><span class="line"><span class="comment">    		*/</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = m-<span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                   dp[i][j] = Math.max(Math.min(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]) - dungeon[i][j],<span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(N×M)，其中 N,MN,M 为给定矩阵的长宽。</p>
<p>空间复杂度：O(N×M)，其中 N,MN,M 为给定矩阵的长宽，注意这里可以利用滚动数组进行优化，优化后空间复杂度可以达到 O(N)O(N)。</p>
]]></content>
      <tags>
        <tag>力扣</tag>
        <tag>刷题</tag>
        <tag>dp</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题：最小路径和</title>
    <url>/2020/07/23/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%9A%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h3 id="力扣刷题：最小路径和问题"><a href="#力扣刷题：最小路径和问题" class="headerlink" title="力扣刷题：最小路径和问题"></a>力扣刷题：最小路径和问题</h3><h4 id="题概："><a href="#题概：" class="headerlink" title="题概："></a>题概：</h4><p>给一个非负数的 m X n 的网格，找出一条从最上到最下的路径，使得路径和最小。</p>
<a id="more"></a>

<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>经典动态规划思想求解，dp（i，j）为到达（i，j）所需要的最小路径和。</p>
<p><em>题目要求只能右走和下走，所以dp（i，j）只能由dp（i-1，j）和dp（i，j-1）得到。即得到dp（i，j）则须得到前二者。</em></p>
<p><strong>边界问题：</strong></p>
<p><strong>当左边界达到，上边界达到（i=0.j=0），也就是dp【i】【j】 = grid【i】【j】为起始点，直接continue跳出此次i，j地点。</strong></p>
<p><strong>当左边界达到，只能往上得到i，j（i=0），dp【i】【j】 = dp【i】【j-1】 + grid【i】【j】。</strong></p>
<p><strong>当上边界达到，只能往右达到i，j（j=0），dp【i】【j】 = dp【i-1】【j】 + grid【i】【j】。</strong></p>
<p><strong>当左上边界皆为达到，dp【i】【j】 = Min（dp【i】【j-1】，dp【i-1】【j】） + grid【i】【j】。</strong></p>
<p><em>其实我们完全不需要建立 dp矩阵浪费额外空间，直接遍历 <code>grid[i][j]修改即可。这是因为：grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] ；原 grid 矩阵元素中被覆盖为 dp 元素</code>后（都处于当前遍历点的左上方），不会再被使用到。</em></p>
<h4 id="例码："><a href="#例码：" class="headerlink" title="例码："></a>例码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length;</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i ==<span class="number">0</span>) &#123;</span><br><span class="line">                    grid[i][j] = grid[i][j-<span class="number">1</span>] + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[i][j] = grid[i-<span class="number">1</span>][j] + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    grid[i][j] = Math.min(grid[i][j-<span class="number">1</span>],grid[i-<span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>力扣刷题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题：分割数组的最大值</title>
    <url>/2020/07/26/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%EF%BC%9A%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h3 id="力扣刷题：分割数组的最大值"><a href="#力扣刷题：分割数组的最大值" class="headerlink" title="力扣刷题：分割数组的最大值"></a>力扣刷题：分割数组的最大值</h3><h4 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h4><p>已知一数组，给定m值，求得将该数组分成m个子集中，哪种分配方式，使得子集中最大值的分配方式在所有分配方式中，此值为最小。</p>
<p><em>输入：</em></p>
<p><em>nums = {7,2,5,10,8};</em></p>
<p><em>m = 2;</em></p>
<p><em>输出：</em></p>
<p><em>18</em></p>
<p><em>解释：</em></p>
<p><em>一共有四种方法将nums分割为2个子集，其中最好的是[7,2,5]和[10,8]的分配方式，求得18为其中的最小。</em></p>
<a id="more"></a>

<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><h5 id="动态规划法："><a href="#动态规划法：" class="headerlink" title="动态规划法："></a>动态规划法：</h5><p>此题中，将f(i,j)描述为数组前i个元素分割为j个子集中所能得到所有分配方式中最小的那个分配方式中的最大子集和。</p>
<p>在进行子集怎么分配。</p>
<h5 id="例码："><a href="#例码：" class="headerlink" title="例码："></a>例码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*初始化操作，记录长度n，数组f，赋初始值皆为最大，</span></span><br><span class="line"><span class="comment">       * 因边界条件时赋初始值为最大，对后面的Min求最小无影响。</span></span><br><span class="line"><span class="comment">       * 而且需要的的值会被替换掉，所以全赋值为最大。</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">       <span class="keyword">int</span> n = nums.length;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * f[i][j]代表nums数组的前i个数分为j个子集，其中求不同分配方式中子集和最大值，哪种分配方式的值最小。</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">       <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           Arrays.fill(f[i], Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*此处sub数组记录nums数组的和</span></span><br><span class="line"><span class="comment">       * sub【n】为前n项和，便于后面枚举k值时，每一个子集的和都有记录</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line">       <span class="keyword">int</span>[] sub = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">           sub[i + <span class="number">1</span>] = sub[i] + nums[i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">           <span class="comment">//此处j的取值最大只能到m，同时也不能分配子集成比已有的i个元素还大。j&lt;=i也&lt;=m。</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Math.min(i,m); j++) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   * f[i][j]的状态方程，是在k=0到i的所有子集分配方式中求得最小的那个。</span></span><br><span class="line"><span class="comment">                   * 在每次不同分配方式中，又有不同的子集和，求得子集和最大的那个。</span></span><br><span class="line"><span class="comment">                   *也就是在枚举i里元素k，f[k][j-1]分割成j-1段，与最后一个数组k+1到i为一段，求得最大值。</span></span><br><span class="line"><span class="comment">                   * 同时后者能表示为到元素i的子集和减去到元素k的子集和。</span></span><br><span class="line"><span class="comment">                   * */</span></span><br><span class="line">                   f[i][j] = Math.min(f[i][j],Math.max(f[k][j - <span class="number">1</span>],sub[i] - sub[k]));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//最后输出fnm为所求的最终结果。</span></span><br><span class="line">       <span class="keyword">return</span> f[n][m];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>力扣刷题</tag>
        <tag>动态分配</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划：POJ1159珠宝问题</title>
    <url>/2020/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9APOJ1159%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>题意：给你一个字符串，可在任意位置添加字符，最少再添加几个字符，可以使这个字符串成为回文字符串。<br>思路：求原串与其逆串的最长公共子序列，然后用串长减去最长公共子序列的长度就是要添加的最少的字符数。</p>
<p>最大公共序列的水题，主要是滚动数组。</p>
<h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>斐波那契数列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码只要用到i-1,与i-2的关系，但开到了100的数组长度，无疑是浪费内存的，</p>
<a id="more"></a>

<p>滚动数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;  <span class="comment">//序列长度</span></span><br><span class="line">	<span class="built_in">string</span> s1, s2;  <span class="comment">//序列</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s1;</span><br><span class="line">	s2 = s1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//将s1序列倒序为s2</span></span><br><span class="line">	&#123;</span><br><span class="line">		s2[i] = s1[n - i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">//临界条件</span></span><br><span class="line">	&#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">		dp[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//dp关键，通过s1数组与s2数组的对比，从s1[0]与s2[0...n]对比，相同的记录在dp[1][1]上，不同使dp[a][j] = 前一个dp与dp[b]的最大值.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a = <span class="number">1</span> - a;  <span class="comment">//滚动数组，减少不必要的数组内存</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				dp[a][j] = dp[<span class="number">1</span>-a][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				dp[a][j] = <span class="built_in">max</span>(dp[a][j - <span class="number">1</span>], dp[<span class="number">1</span>-a][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; n - <span class="built_in">max</span>(dp[<span class="number">0</span>][n], dp[<span class="number">1</span>][n]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Over！</p>
]]></content>
      <tags>
        <tag>POJ</tag>
        <tag>动态规划，最大公共序列</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣：1.两数相加题</title>
    <url>/2020/07/09/%E5%8A%9B%E6%89%A3%EF%BC%9A1-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E9%A2%98/</url>
    <content><![CDATA[<h3 id="力扣刷题：两数相加"><a href="#力扣刷题：两数相加" class="headerlink" title="力扣刷题：两数相加"></a>力扣刷题：两数相加</h3><p><strong>题括</strong>：</p>
<p>已知数组nums{1，2，7，4}，求得其中2值相加target=8的nums的下标。</p>
<a id="more"></a>



<p><strong>思路：</strong></p>
<p>1.<em>暴力求解法</em>：</p>
<p>通过2个for循环遍历nums中能使target=8的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j] == target) &#123;</span><br><span class="line">                    ans[<span class="number">0</span>] = i;</span><br><span class="line">                    ans[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.<em>两指针求解法</em></p>
<p>利用快速排序的思想，将nums数组快速排序后，将i，j两指针分别定义nums的最小和最大值，i++，j–，直到求到target值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 力扣第一题：2数相加</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">/*Copy数组保留原始nums排序的下标，便于找到目的元素后找回下标值*/</span></span><br><span class="line">       <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">       System.arraycopy(nums,<span class="number">0</span>,copy,<span class="number">0</span>,nums.length);</span><br><span class="line">       <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*利用快速排序，从2头找效率更高*/</span></span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       <span class="keyword">for</span>(i = <span class="number">0</span>,j = nums.length-<span class="number">1</span>;i&lt;j;) &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]+nums[j] &lt; target) &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j] &gt; target) &#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j] == target) &#123;</span><br><span class="line">               m = nums[i];</span><br><span class="line">               n = nums[j];</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*k值拿出是如果nums数组中有一样的元素，导致找该数时下标混乱*/</span></span><br><span class="line">       <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;copy.length;k++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(m == copy[k]) &#123;</span><br><span class="line">               ans[<span class="number">0</span>] = k;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">0</span>;o&lt;copy.length;o++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(n == copy[o] &amp;&amp; o != k) &#123;<span class="comment">/*在此体现i != k*/</span></span><br><span class="line">               ans[<span class="number">1</span>] = o;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span>  ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>3.<em>Java中的HashMap求解</em>   <strong>速度最快</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[]twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length ; i++) &#123;</span><br><span class="line">        <span class="comment">/*此处应求下标，所以键为元素值，值为下标。target-nums[i]求出Map也就是nums数组的另一半*/</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(target - nums[i])) &#123;  </span><br><span class="line">            <span class="comment">/*//此处返回秒啊，因为是2个值，在第一个值i确立情况下，得出另一个值target-nums[i],因i还未++直接能将2值跳出*/</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target - nums[i]),i&#125;;  </span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i],i);  <span class="comment">//键值对放入map中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;  <span class="comment">//未找到元素返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>力扣</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记:算法贪心法</title>
    <url>/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AE%97%E6%B3%95%E8%B4%AA%E5%BF%83%E6%B3%95/</url>
    <content><![CDATA[<h2 id="数据结构与算法：-贪心法"><a href="#数据结构与算法：-贪心法" class="headerlink" title="数据结构与算法： 贪心法"></a>数据结构与算法： 贪心法</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>贪心算法总是能做出当前状态最好的选择，不是从整体最优考虑，每次选择都是局部最优解。</p>
<p><strong>核心是所使用的情况是每一步的最优选择能导致最后结果的整体最优解。</strong></p>
<p>贪心法与递归不同，前者的每一步都是选择<strong>当前最佳结果</strong>的，递归推进的每一步是固定的递归式。</p>
<p>贪心法将当时看似最佳的<strong>贪心选择</strong>，不断地将问题实例归纳为更小的类似子问题。</p>
<blockquote>
</blockquote>
]]></content>
      <tags>
        <tag>贪心法</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：狐狸与小狗（回溯法）</title>
    <url>/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8B%90%E7%8B%B8%E4%B8%8E%E5%B0%8F%E7%8B%97%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="狐狸与小狗"><a href="#狐狸与小狗" class="headerlink" title="狐狸与小狗"></a>狐狸与小狗</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h3><p>固定棋盘为8 x 8，有两个玩家：狐狸与小狗。初始的时候有4只小狗和1只狐狸，狗在棋最上的黑格中，狐狸在最下黑格的某个中，棋盘左上为原点，向下为行正，向右为列正。</p>
<p><img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8B%90%E7%8B%B8%E4%B8%8E%E5%B0%8F%E7%8B%97%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89/%E6%A3%8B1.png" alt></p>
<a id="more"></a>

<p>移动规则：</p>
<ul>
<li>二位轮流下棋</li>
<li>狐狸每轮可以斜上或者斜下一格，小狗只能斜下一格且每次只能动一枚棋子</li>
<li>皆只能在黑格中移动</li>
</ul>
<p>游戏目标：</p>
<ul>
<li><p>小狗将狐狸围住无路可走时，狗赢</p>
</li>
<li><p>狐狸到达最上方一格时，狐赢</p>
<p><img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%8B%90%E7%8B%B8%E4%B8%8E%E5%B0%8F%E7%8B%97%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89/%E6%A3%8B2.png" alt></p>
</li>
</ul>
<p><strong>游戏不存在平局，四只狗都不能动狐便能一直移动取胜</strong></p>
<h3 id="2-输入与输出"><a href="#2-输入与输出" class="headerlink" title="2.输入与输出"></a>2.输入与输出</h3><p>输入包括多组数据，第一行t表示接下来t(t&lt;=3000)种局面。对于每一种局面，三组数据构成。</p>
<p>第一行为整数0或1。0代表狐下，1代表狗下。</p>
<p>第二行为两个整数，空格分开，依次是狐的行坐标fr与列坐标fl。</p>
<p>第三行为八个整数，空格分开，第一支狗的fr，fl依次到第四只狗。</p>
<p>输出则狐赢，输出 Fox win。</p>
<p>狗赢，输出 Dog win。</p>
<h3 id="3-个人理解"><a href="#3-个人理解" class="headerlink" title="3.个人理解"></a>3.个人理解</h3><p><strong>博弈树概念</strong></p>
<p>设想下象棋，甲乙对抗，假定此时甲走，甲有多种走法（无论好坏）：对甲的每种走法乙也有可能有与之对应的多种走法。乙走后甲也对应有多种走法，如此反复。</p>
<p>由此建立棵博弈树，每次走法罗列出来，<strong>每个结点对应一次棋局，每条边对应一种棋局</strong>。</p>
<p>树根结点为棋局初始局面，根结点的所有子结点表示甲执行的某个行动后的棋局，<strong>树的每一层就是甲或者乙的某次下棋的所有的一次棋局</strong>。叶子结点表示分出胜负的结点。</p>
<p>博弈树指由于<em>动态博弈</em> 参与者的行动有先后顺序，因此可以依次将参与者的行动展开成一个树状图形。</p>
<p>特点如下：</p>
<ul>
<li>双方博弈的初始棋局是树的根结点。</li>
<li>在博弈种，“或”结点和“与”结点时逐层交替出现的。自己一方扩展的结点之间是“或”关系，对方扩张的结点之间是与的关系。双方轮流扩展结点。</li>
<li>整个博弈过程始终站在某一方的立场上。</li>
</ul>
<p>如果轮到甲行动后，不管甲如何，甲都胜，说明甲处于“必胜态”，反之“必败态”。</p>
<p>除了极少数的棋类，大多棋类，中国象棋，围棋，五子棋等，皆无建立完全搜索树的可能。</p>
<p>一方面是很多情形无法到达叶子结点，如一棋子反复来回则无限循环。</p>
<p>二是上种情况排除，此棵树上结点数量也多到无法处理（“人工智能”与“机器博弈”分支研究此方向）</p>
<p><strong>此题下的博弈树</strong></p>
<p>棋盘为 8 x 8 = 64的规模，只有32个黑格能落棋。</p>
<p>狐有四种走法，狗有8种，小狗只能右下或者左下，当四只走到最下层则不能走。</p>
<p>博弈树深度为4 x 7 x 2之内，具备建立可能。</p>
<hr>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>回溯法</tag>
        <tag>算法，博弈树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划：楼层置球</title>
    <url>/2020/06/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E6%A5%BC%E5%B1%82%E7%BD%AE%E7%90%83/</url>
    <content><![CDATA[<h2 id="动态规划：poj3783-楼层置球"><a href="#动态规划：poj3783-楼层置球" class="headerlink" title="动态规划：poj3783 楼层置球"></a>动态规划：poj3783 楼层置球</h2><p><img src="/2020/06/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E6%A5%BC%E5%B1%82%E7%BD%AE%E7%90%83/poj3783.png" alt></p>
<a id="more"></a>

<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>该问题是求出某个楼层K，小球到这层，最坏情况（需一层一层仍确认），至少需几次确定此K值。</p>
<p>可用动态规划思想，将</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[i][j]表示，i为楼层，j为球数。</span><br></pre></td></tr></table></figure>

<p>具体理解以后补，我自己也没这么搞起动态规划思想。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OverProblemDP</span><span class="params">(<span class="keyword">int</span> <span class="built_in">floor</span>, <span class="keyword">int</span> ball, <span class="keyword">int</span> **dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">floor</span> + <span class="number">1</span>; i++)  <span class="comment">//从0开始到floor+1，将楼层的所有ball置0，初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fill</span>(dp[i], dp[i] + ball + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//二种情况：一是球只有1个，最坏情况最少置数为i-1，二是到楼层0时，置0.</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">floor</span> + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i][<span class="number">1</span>] = i - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ball + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//dpij数组，从2开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">floor</span> + <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; ball + <span class="number">1</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> over = INT_MAX;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; k++)  <span class="comment">//k为预期刚好碎的楼层，求出此楼层的最坏情况下最少置数。</span></span><br><span class="line">			&#123;</span><br><span class="line">				over = <span class="built_in">min</span>(over, <span class="built_in">max</span>(dp[k][j - <span class="number">1</span>], dp[i - k][j]));  <span class="comment">//max内求，是因为题目要求，最坏情况所以我二者最大，然后与前一个over相比求最少置数。</span></span><br><span class="line">			&#125;</span><br><span class="line">			dp[i][j] = over + <span class="number">1</span>;  <span class="comment">//改此也算一次，所以+1.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">floor</span>][ball];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">	<span class="keyword">while</span> (N--&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">floor</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ball = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ball &gt;&gt; <span class="built_in">floor</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> **dp = <span class="keyword">new</span> <span class="keyword">int</span>*[<span class="built_in">floor</span> + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">floor</span>+<span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			dp[i] = <span class="keyword">new</span> <span class="keyword">int</span>[ball + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; n &lt;&lt;<span class="string">" "</span>&lt;&lt; OverProblemDP(<span class="built_in">floor</span>, ball, dp)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">free</span>(dp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>动态规划，算法，poj</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识补漏：‘i++与++i’区别</title>
    <url>/2020/04/28/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E6%BC%8F%EF%BC%9A%E2%80%98i++%E4%B8%8E++i%E2%80%99%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="c-中i-与-i的区别"><a href="#c-中i-与-i的区别" class="headerlink" title="c++中i++与++i的区别"></a>c++中i++与++i的区别</h2><p>i++和++i命令的区别有：</p>
<p>1、赋值顺序不同</p>
<p>++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。</p>
<p>因为++i 是后面一步才赋值的，所以它能够当作一个变量进行级联赋值，++i = a =b，即 ++i 是一个左值；i++ 的后面一步是自增，不是左值。</p>
<p>形象的理解可以是i++先做别的事，再自己加1，++i先自己加1，再做别的事情。</p>
<a id="more"></a>

<p>2、效率不同</p>
<p>比如i=3，b=i++就是说b=3,完成之后让i变成4，b=++i就是先让i++变成4，然后b=4，其中++i比i++效率要高些。一般来说在循环域里面，这两者并没有什么很大的区别，但是要注意其生存周期，以及i值在程序流中的变化。</p>
<p>3、 i++ 不能作为左值，而++i 可以。</p>
<p>左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。一般来说，左值是可以放到赋值符号左边的变量。</p>
<p>但能否被赋值不是区分左值与右值的依据。比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。左值与右值的根本区别在于是否允许取地址&amp;运算符获7a64e4b893e5b19e31333366303839得对应的内存地址。</p>
<p>比如：</p>
<p>int i = 0;</p>
<p>int *p1 = &amp;（++i）；//正确</p>
<p>int *p2 = &amp;（i++）；//错误</p>
<p>++i = 1；//正确</p>
<p>i++ = 1；//错误</p>
<p><a href="https://iknow-pic.cdn.bcebos.com/f7246b600c338744a256ee365c0fd9f9d62aa0ed" target="_blank" rel="noopener"><img src="https://iknow-pic.cdn.bcebos.com/f7246b600c338744a256ee365c0fd9f9d62aa0ed?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" alt="img"></a></p>
<p><strong>扩展资料</strong>：</p>
<p>当i=5时，s=(++i)+(++i)和s=(i++)+(i++)的值：</p>
<p>1、当i=5时，s=(++i)+(++i)=13 先算第一个(++i)，++在前面,就把i先加1再把赋值，即先把i变为6然后再得出(++i)的值为6，这时i已经变为6了，</p>
<p>再计算第二个(++i)，++在前面也是先把i加1后再赋值，不过这时的i已经为6了，第一步的时候把i变成6了的，然后加1的话就变成7了，所以第二个(++i)的值为7，s=(++i)+(++i)=6+7=13。</p>
<p>2、s=(i++)+(i++)=11 先算第一个(i++)，i在前面，就先赋值再把i加1，即(i++)的值为5，i的值变为6，第二个(i++)，i在前面，先赋值再把i加1，这个时候的i已经为6了，即(i++)的值为6，而i已经变为7了。所以s=(i++)+(i++)=5+6=11。</p>
<p>参考资料来源：<a href="https://baike.baidu.com/item/自增自减运算符" target="_blank" rel="noopener">百度百科-自增自减运算符</a></p>
<p>参考资料来源：<a href="https://baike.baidu.com/item/%2B%2B" target="_blank" rel="noopener">百度百科-++</a></p>
]]></content>
      <tags>
        <tag>基础知识，补漏</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：顺序表</title>
    <url>/2020/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="代码记录"><a href="#代码记录" class="headerlink" title="代码记录"></a>代码记录</h2><p><strong>数据结构的基础结构之–顺序表</strong></p>
<p>包含顺序表的初始化，置空，判空，打印，插入，删除，查找，元素定位，表与表的添加。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>  //线性表的顺序存储结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType Data[MAXSIZE];  <span class="comment">//数组存储元素</span></span><br><span class="line">	<span class="keyword">int</span> length;  <span class="comment">//长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Print</span><span class="params">(ElemType e)</span>  <span class="comment">//打印元素e</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>, e);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList *s)</span>  <span class="comment">//初始化，长度为0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s-&gt;length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(SqList s)</span>  <span class="comment">//线性表若为空返回true，否在返回false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s.length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(SqList *s)</span>  <span class="comment">//将线性表重置为空表，与初始化操作相同</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s-&gt;length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListLength</span><span class="params">(SqList s)</span>  <span class="comment">//返回线性表长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ElemGet</span><span class="params">(SqList s,<span class="keyword">int</span> i, ElemType *e)</span>  <span class="comment">//从线性表中获得元素的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s.length == <span class="number">0</span> || i &lt; <span class="number">1</span> || i &gt; s.length)  <span class="comment">//i值有误或者线性表里没有元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	*e = s.Data[i - <span class="number">1</span>];  <span class="comment">//数组是从0开始，用i定位就需要减1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">LocateElem</span><span class="params">(SqList s, ElemType e)</span>  <span class="comment">//找到元素e在线性表中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (s.length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.Data[i] == e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;  <span class="comment">//找到该元素后跳出循环</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= s.length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InsertList</span><span class="params">(SqList *s, <span class="keyword">int</span> i, ElemType e)</span>  <span class="comment">//在s中第i个位置之前插入元素e</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;length == MAXSIZE)  <span class="comment">//满</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;s-&gt;length + <span class="number">1</span>)  <span class="comment">//位置i有误</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &lt;= s-&gt;length)  <span class="comment">//插入时不在表尾</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (k = s-&gt;length - <span class="number">1</span>; k &gt;= i - <span class="number">1</span>; k--)  <span class="comment">//将要插入位置之后的元素后移一位</span></span><br><span class="line">	&#123;</span><br><span class="line">		s-&gt;Data[k + <span class="number">1</span>] = s-&gt;Data[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;Data[i - <span class="number">1</span>] = e;  <span class="comment">//元素插入并长度加1</span></span><br><span class="line">s-&gt;length++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeleteList</span><span class="params">(SqList *s, <span class="keyword">int</span> i, ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;length == <span class="number">0</span>)  <span class="comment">//空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;s-&gt;length )  <span class="comment">//位置i有误</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*e = s-&gt;Data[i - <span class="number">1</span>];  <span class="comment">//将被删除的元素返回给e</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; s-&gt;length)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (k = i; k &lt; s-&gt;length; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			s-&gt;Data[k - <span class="number">1</span>] = s-&gt;Data[k];  <span class="comment">//将删除位置后面的元素前移i个单位</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;length--;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">TraverList</span><span class="params">(SqList s)</span>  <span class="comment">//遍历所有线性表中的元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Print(s.Data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionList</span><span class="params">(SqList *sa, SqList sb)</span>  <span class="comment">//将所有的在线性表sb但不在sa中的元素插入sa</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sa_len, sb_len, i;</span><br><span class="line">	ElemType e;</span><br><span class="line">	sa_len = ListLength(*sa);</span><br><span class="line">	sb_len = ListLength(sb);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; sa_len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ElemGet(sb, i, &amp;e);  <span class="comment">//sb中第i个元素赋值于e</span></span><br><span class="line">		<span class="keyword">if</span> (!LocateElem(*sa, e))  <span class="comment">//如果线性表sa中不存在与e相同的元素</span></span><br><span class="line">		&#123;</span><br><span class="line">			InsertList(sa, ++sa_len, e);  <span class="comment">//将sb中有而sa中无的元素队尾插入sa</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqList S;</span><br><span class="line">	ElemType e1,e2;</span><br><span class="line"></span><br><span class="line">	InitList(&amp;S);  <span class="comment">//初始化,将1到10插入线性表</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		InsertList(&amp;S, i, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"初始的线性表元素为：\n"</span>);</span><br><span class="line">	TraverList(S);</span><br><span class="line">	</span><br><span class="line">	InsertList(&amp;S, <span class="number">3</span>, <span class="number">666</span>);  <span class="comment">//在第三个元素位置插入666</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"在第三个元素位置插入666后\n"</span>);</span><br><span class="line">	TraverList(S);</span><br><span class="line">	</span><br><span class="line">	DeleteList(&amp;S, <span class="number">8</span>, &amp;e1);  <span class="comment">//将第8个元素删除</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"将第8个元素删除后,删除的元素e为=%d\n"</span>,e1);</span><br><span class="line">	TraverList(S);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"寻找元素为65是否在在线性表内，当前线性表为：\n"</span>);</span><br><span class="line">	TraverList(S);</span><br><span class="line">	e2 = LocateElem(S, <span class="number">65</span>);</span><br><span class="line">	<span class="keyword">if</span> (e2 == <span class="number">65</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, e2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"没有该元素\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>顺序表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：栈的定义与基本操作</title>
    <url>/2020/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h3><p>​    一种可以实现“先进后出”的数据存储结构，数据的插入和删除只能在数据的一端进行。</p>
<p>内存分为静态内存和动态内存。</p>
<p>​    静态内存在栈中分配，动态内存在堆中分配。</p>
<p>​    栈：由操作系统自动分配释放，存放函数的参数值，<strong>局部变量</strong>的值等。</p>
<p>​    堆：由操作者分配释放，若不则程序结束时由os回收（类似c语言中malloc函数分配的空间）。</p>
<a id="more"></a>

<h3 id="栈的分类"><a href="#栈的分类" class="headerlink" title="栈的分类"></a>栈的分类</h3><p>​    <strong>静态栈</strong> ：以数组作为数据的存储。</p>
<p>​    <strong>动态栈</strong> ：以链表作为数据的存储方式。</p>
<h3 id="栈的相关操作（采用链表的动态栈）"><a href="#栈的相关操作（采用链表的动态栈）" class="headerlink" title="栈的相关操作（采用链表的动态栈）"></a>栈的相关操作（采用链表的动态栈）</h3><p>​    因为是链表实现栈，其实其本质就是一个链表，只不过对该链表的插入（push）和删除（pop）操作都在该链表的一端进行（该段被称为栈顶，且人为限制就是在该栈顶进行操作），所以该链表具备了<strong>先进后出</strong>的特性，则被称为栈。</p>
<p>​    所以，栈仅仅需要一个栈顶，该栈顶指向该链表的被称为栈顶端的节点（所以栈顶也是一个该Node类型的指针）。</p>
<h3 id="相关代码及其注释"><a href="#相关代码及其注释" class="headerlink" title="相关代码及其注释"></a>相关代码及其注释</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>  //定义栈中每个结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;  <span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>  <span class="comment">//指针域，指向下一个结点</span></span><br><span class="line">&#125;Node,* PNode; <span class="comment">//定义指针类名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PNode ptop;  <span class="comment">//栈的栈顶</span></span><br><span class="line">	PNode pbottom;  <span class="comment">//栈底</span></span><br><span class="line">&#125;Stack,* PStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(PStack ps)</span>  <span class="comment">//判空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PNode p = ps-&gt;ptop;</span><br><span class="line">	<span class="keyword">if</span> (p==<span class="literal">NULL</span>||p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(PStack p)</span>  <span class="comment">//初始化栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;ptop = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//定义一个头结点，使top指向它并分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;ptop == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;pbottom = p-&gt;ptop;  <span class="comment">//令bottom和top皆指向头结点</span></span><br><span class="line">		p-&gt;ptop-&gt;next = <span class="literal">NULL</span>;  <span class="comment">//将头指向下一个置为空</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PushStack</span><span class="params">(PStack ps, ElemType val)</span>  <span class="comment">//压栈操作，将元素val入栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PNode pnew = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));  <span class="comment">//定义一个新节点便于操作</span></span><br><span class="line">	<span class="keyword">if</span> (pnew-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	pnew-&gt;data = val;  <span class="comment">//将该元素赋值于结点上</span></span><br><span class="line">	pnew-&gt;next = ps-&gt;ptop;  <span class="comment">//指针赋值的顺序不能乱，为避免top所指向的地址丢失，所以让新结点指针域指向top地址</span></span><br><span class="line">	ps-&gt;ptop = pnew;  <span class="comment">//令top指针指向新的结点</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElemType <span class="title">PopStack</span><span class="params">(PStack ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ElemType res;</span><br><span class="line">	<span class="keyword">if</span> (isEmpty(ps))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"栈为空，无法pop"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		PNode p = ps-&gt;ptop;  <span class="comment">//先将需要被pop的结点存储起来</span></span><br><span class="line">		ps-&gt;ptop = p-&gt;next;  <span class="comment">//将栈的top指向下一个结点</span></span><br><span class="line">		res = p-&gt;data;</span><br><span class="line">		<span class="built_in">free</span>(p);  <span class="comment">//地址释放</span></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(PStack ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isEmpty(ps)==<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"栈为空，无法遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	PNode p = ps-&gt;ptop;  <span class="comment">//让新定义的结构体指针指向栈顶元素</span></span><br><span class="line">	<span class="keyword">while</span> (p != ps-&gt;pbottom)  <span class="comment">//从栈顶开始一直指到栈底后跳出循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p-&gt;data;  </span><br><span class="line">		p = p-&gt;next;  <span class="comment">//让当前结点指向下一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stack S;</span><br><span class="line">	<span class="keyword">char</span> str[MAXSIZE];</span><br><span class="line">	<span class="keyword">char</span> str1[MAXSIZE];</span><br><span class="line">	InitStack(&amp;S);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; str[i];</span><br><span class="line">		<span class="keyword">if</span> (str[i] == <span class="string">'@'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		PushStack(&amp;S, str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"入栈后遍历为："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Traverse(&amp;S);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXSIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		str1[i] = PopStack(&amp;S);</span><br><span class="line">		<span class="keyword">if</span> (str1[i] == str[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; str1[i] &lt;&lt; <span class="string">"="</span> &lt;&lt; str[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"不是回文"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty(&amp;S) == <span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"回文匹配正确"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次搭载Hexo博客。。</title>
    <url>/2020/04/22/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E8%BD%BDHexo%E5%8D%9A%E5%AE%A2%E3%80%82%E3%80%82/</url>
    <content><![CDATA[<h2 id="个人博客搭载目的"><a href="#个人博客搭载目的" class="headerlink" title="个人博客搭载目的"></a>个人博客搭载目的</h2><p>  起初，在刷题的时候想着自己做了这么多题，写着写着就忘了，得搞点什么东西来记录下。而手边又没什么工具，记得在当初在b站刷到羊哥的个人博客搭载视频的时候，卧槽这就是程序员的浪漫吗，于是就进了这个大坑。</p>
<hr>
<p>  还记得当初自己上高中的时候，就想自己拥有一个网站，然后打扮的漂漂亮亮的，播着自己喜欢的音乐，<del>绝不能让别人知道我当初这个目的是想…</del>打开视频，噢我明白了，然后实际操作，<strong>懵逼</strong>。</p>
<a id="more"></a>

<h3 id="搭载环境和Hexo下载"><a href="#搭载环境和Hexo下载" class="headerlink" title="搭载环境和Hexo下载"></a>搭载环境和Hexo下载</h3><p>  我就不用文字描述了，直接上羊哥的保姆级视频，<strong>羊哥的是Mac，win可以打开弹幕来看别人的对比</strong>。</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.videocard.0</a> </p>
</blockquote>
<h3 id="主要描述自己所遇到的坑吧"><a href="#主要描述自己所遇到的坑吧" class="headerlink" title="主要描述自己所遇到的坑吧"></a>主要描述自己所遇到的坑吧</h3><h4 id="new文件时的坑"><a href="#new文件时的坑" class="headerlink" title="new文件时的坑"></a>new文件时的坑</h4><p>  首先装完羊哥的那些环境后，可能在用代码执行期间可能会报各种错，<strong>Git也是要装上的，装上Git直接在blog文件中用git bush打开，其他步骤都和羊哥的一样，这里git安装狂神说讲得很清楚</strong>。</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1FE411P7B3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1FE411P7B3</a></p>
</blockquote>
<p>  在hexo中new一个博客时，因为win没有vim打开的文档的方式，但在git bush中却能打开。打开文档后，这时我们照着羊哥的敲完选择退出时，我们要先按ESC再按大写状态的ZZ就能退出了。</p>
<p> 这时萌新的我跟到这里还是懵逼的，哎，没办法谁叫自己菜。</p>
<p>  <strong>这里推荐new完后，进行博客写还是用Typora写好些，主要是拿黑框框写博客感觉没那个意境。只要在hexo中建立md文件后选用Typora进行编写然后保存，最后再用hexo推送就ok</strong></p>
<hr>
<h4 id="选用gitee作为服务器搭载的坑"><a href="#选用gitee作为服务器搭载的坑" class="headerlink" title="选用gitee作为服务器搭载的坑"></a>选用gitee作为服务器搭载的坑</h4><p>  因为github实在太慢墙太高，我是用的国内的gitee，然后就踩了个大坑。</p>
<p>  <strong>注意，项目的存放格式一定要和用户名一致，这很重要，如果名字有大写字母的统一用小写，血的教训</strong>。</p>
<p>  用gitee的话，如果你上述步骤跟羊哥都走对了，但最后打开到公网还是404了，我只想说兄弟你也和我一样惨，但别放弃。我找了很多网站，最后发现</p>
<p><img src="/2020/04/22/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E8%BD%BDHexo%E5%8D%9A%E5%AE%A2%E3%80%82%E3%80%82/gitee%E6%90%AD%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt></p>
<p>  <strong>点这个服务进入</strong></p>
<p><img src="/2020/04/22/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E8%BD%BDHexo%E5%8D%9A%E5%AE%A2%E3%80%82%E3%80%82/gitee2png.png" alt></p>
<p><strong>得显示出这个网站地址才能算成功，如果没显示可以点右边那个免费使用pro一下再点下面的更新，按道理不用pro也能点更新，不过我那时没看到直接点了pro试用了</strong></p>
<p>出现了这个网站后你就发现，卧槽公网能访问了，没错，到了这里你就成功了！！！</p>
<h1 id="最后最重要的，记得在config下的文件编写中：-后面记得有个空格，这很重要！！！关于调用有关在hexo下的：大部分都需要个空格，不然推送就会报错！！！"><a href="#最后最重要的，记得在config下的文件编写中：-后面记得有个空格，这很重要！！！关于调用有关在hexo下的：大部分都需要个空格，不然推送就会报错！！！" class="headerlink" title="最后最重要的，记得在config下的文件编写中： 后面记得有个空格，这很重要！！！关于调用有关在hexo下的：大部分都需要个空格，不然推送就会报错！！！"></a>最后最重要的，记得在config下的文件编写中： 后面记得有个空格，这很重要！！！关于调用有关在hexo下的：大部分都需要个空格，不然推送就会报错！！！</h1>]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>个人博客搭载</tag>
        <tag>gitee搭载</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记：映射（map）的基本操作</title>
    <url>/2020/07/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%98%A0%E5%B0%84%EF%BC%88map%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="映射（map）的基本操作"><a href="#映射（map）的基本操作" class="headerlink" title="映射（map）的基本操作"></a>映射（map）的基本操作</h3><p><strong>定义</strong>：通常知道一个元素的部分关键信息，希望能找到该元素。映射（Map）数据结构就是为此设计的。</p>
<p>映射通过存放<strong>键/值对</strong>，通过键就能找到对应的值。</p>
<p>Java类中为映射提供了2种通用实现：HashMap，TreeMap。</p>
<p>前者散列映射对键进行散列，后者树映射根据键的顺序将元素组织成一个搜索树。</p>
<p><strong>散列或比较函数只应用于键，于键关联的值不会造成影响</strong>。</p>
<a id="more"></a>

<p><strong>特点：</strong></p>
<p>1.添加一个对象时，必须提供一个键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> staff = <span class="keyword">new</span> HashMap&lt;String,Employee&gt;();</span><br><span class="line">staff.put(<span class="string">"string类型值的键"</span>,Employee);  <span class="comment">//前者为键，后者为值。</span></span><br></pre></td></tr></table></figure>

<p>2.检索元素时必须提供键。</p>
<p>3.键必须唯一，当2次put时会取第二次put的值。</p>
<p>4.put存放，remove移除该元素，size返回元素数量。</p>
<p>5.迭代处理映射种的键值对，一般使用<strong>forEach</strong>方法，例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">staff.forEach((k,v) -&gt; System.out.println(<span class="string">"key="</span>+key+<span class="string">"v="</span>+v));</span><br></pre></td></tr></table></figure>



<p><strong>API:</strong></p>
<p>Map:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span>  <span class="comment">//获取键key的值，无则返回NULL。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key,V defaultValue)</span>  <span class="comment">//获得键值，未找到则返回default</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key,V value)</span>  <span class="comment">//将键/值放入Map中，已有的键，替换新的值。此方法返回旧值，如无则NULL</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">A.<span class="title">putAll</span><span class="params">(B)</span>  <span class="comment">//将MapB中的键值对全放入A中去。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object Key)</span>  <span class="comment">//如映射中有此Key返回true。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object Key)</span>  <span class="comment">//如映射中有此Value返回true。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">A.<span class="title">forEach</span><span class="params">()</span>  <span class="comment">//迭代Map中进行括号的操作。</span></span></span><br></pre></td></tr></table></figure>



<p><strong>例码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> staff = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">       staff.put(<span class="string">"1"</span>,<span class="string">"a"</span>);</span><br><span class="line">       staff.put(<span class="string">"2"</span>,<span class="string">"b"</span>);</span><br><span class="line">       staff.put(<span class="string">"3"</span>,<span class="string">"c"</span>);</span><br><span class="line">       staff.put(<span class="string">"4"</span>,<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(staff);</span><br><span class="line"></span><br><span class="line">       staff.remove(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">       staff.put(<span class="string">"3"</span>,<span class="string">"song"</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(staff.get(<span class="string">"3"</span>));</span><br><span class="line"></span><br><span class="line">       staff.forEach((k,v)-&gt;</span><br><span class="line">               System.out.println(<span class="string">"Key="</span>+k+<span class="string">", value="</span>+v));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=a, <span class="number">2</span>=b, <span class="number">3</span>=c, <span class="number">4</span>=d&#125;</span><br><span class="line">song</span><br><span class="line">Key=<span class="number">1</span>, value=a</span><br><span class="line">Key=<span class="number">3</span>, value=song</span><br><span class="line">Key=<span class="number">4</span>, value=d</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
        <tag>映射</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心法简单例题及其理解</title>
    <url>/2020/05/07/%E8%B4%AA%E5%BF%83%E6%B3%95%E7%AE%80%E5%8D%95%E4%BE%8B%E9%A2%98%E5%8F%8A%E5%85%B6%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h3><ul>
<li><p><em>问题描述</em> ：有一组数据[-2,-3,-5,3,2,0],需要用固定长度的闭区间覆盖这些点，求最少用多少个闭区间。</p>
</li>
<li><p>求解：将数据递增排序，用temp记录数轴上最左端（min）的点的值，然后将其他皆比它大的数一一进行相减，x【i】-temp，当循环到大于覆盖块长度k时的x【i】，将temp进行记录作为新的值，使用块数m+1，最终返回次数m的值。</p>
<a id="more"></a>
</li>
<li><p><strong>算法证明</strong>：在x数组递增排序后，满足<strong>最优子结构性质</strong>，下面证明算法具有贪心选择性。</p>
</li>
<li><p>对于某个点x来说，如果x落在覆盖闭区间集T内，T的长度没有发生改变，则不再需要进一步证明。如果x不属于覆盖区间集之<strong>内</strong>，那么必定在覆盖区间<strong>之间</strong>，假设区间【s，t】，s不属于全部temp值集，那么【s，t】就会在覆盖块<strong>之间</strong>，与覆盖块之间不存在任何x中的点<strong>假设矛盾</strong>，从而证明算法正确。</p>
</li>
<li><p><strong>算法分析</strong>：快速排序算法时间复杂度为O(nlog2^n)，for循环的时间O(n),所以本算法时间复杂度为：O(nlog2^n)。</p>
</li>
<li><p>算法代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贪心法区间覆盖问题，x[]记录每个结点的数值,n记录x数组长度,m记录所用覆盖快个数,k每个覆盖块的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qujianfugai</span><span class="params">(<span class="keyword">int</span> x[],<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m = <span class="number">1</span>;</span><br><span class="line">	sort(x, x + n);  <span class="comment">//将x数组从小到大排序</span></span><br><span class="line">	<span class="keyword">int</span> temp = x[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x[i] - temp &gt; k)  <span class="comment">//当x【i】数值-temp最左端的数值大于覆盖块长度，重新记录temp并m加1</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp = x[i];</span><br><span class="line">			m++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x[<span class="number">5</span>] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span>  n = <span class="number">5</span>, m = <span class="number">0</span>, k = <span class="number">2</span>;</span><br><span class="line">	m = qujianfugai(x, n, m, k);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; m;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <tags>
        <tag>贪心法</tag>
        <tag>例题</tag>
      </tags>
  </entry>
</search>
